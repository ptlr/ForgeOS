# <h1 align="center">内存信息查询</h1>

## 一、参考信息

[Detecting Memory (x86)](https://wiki.osdev.org/Detecting_Memory_(x86))

一个64位操作系统的设计与实现(7.2获取物理地址空间信息）

操作系统真像还原(5.1获取物理内存容量)

## 二、int 0x15

### 1、Memory Map Entry结构

这个结构，共20字节，第一个8字节保存段地址（Base address），第二个8字节保存区域的长度，后四的字节则保存探测到的内存类型。

在ACPI 3.x中，这个结构可能会扩展为24字节，为兼容APCI 3.x, 在学习的过程中使用24字节的版本保存这个结构。

此外每次开始把这个结构体最后的8字节标记为1，如果这个标记被覆盖，则说明返回的是24字节。

内存类型：

| 类型值 | 类型说明           | 备注             |
| :----: | ------------------ | ---------------- |
| 0x0001 | 可用RAM            |                  |
| 0x0002 | 待用的区域，不可用 | 不可用，不关注。 |
| 0x0003 | ACPI 回收内存      | 不可用，不关注。 |
| 0x0004 | ACPI NVS内存       | 不可用，不关注。 |
| 0x0005 | 坏内存区域         | 不可用，不关注。 |

### 2、函数使用说明

参数：

```
(EAX)=0xE820 ; 0x15号中断的子功能号
EBX保存访问第几个内训信息结构
ECX设置成要查询的字节数，此处设置成24
EDX设置成0x534D4150,这个时"SMAP"
ES:DI 指向信息结构保存的位置，不会自增，需要自己动手
```

返回结果：

```
成功：
EAX=0x534D4150，需要重新设置成为0xE820
CF标志清空
EBX为非零值，保存下一个要访问的内存信息结构项，再次为零时意味着没有下一个内存信息结构体。
CL中包含MemoryMapEntry的长度，通常是20
失败：
失败时CF会置位，第一次调用就置位说明"不支持E820功能(unsupported function)"
```



